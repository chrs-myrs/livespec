---
implements: specs/workspace/workspace-agent.spec.md
generated: 2025-10-27T00:00:00Z
generator: livespec/generate-project-config
version: 3.1.0
note: Generated from PURPOSE.md and specs/workspace/ - to update, use prompts/4-evolve/4d-regenerate-agents.md
---

> **âš ï¸ Generated File**: Do not edit directly. See frontmatter for regeneration instructions.

# LiveSpec Agent Configuration

## Summary

This document provides essential LiveSpec knowledge for AI agents. Cache this once per session to handle 90% of LiveSpec operations without repeated context7 lookups.

**Purpose**: Specifications that live with your code - preventing drift between docs and implementation.

**Success Criteria**:
- Specs remain synchronized with code throughout development
- AI agents have structured context for effective assistance
- Documentation stays current without becoming a maintenance burden

---

## âš ï¸ CRITICAL: Spec-First Guidance (Principle #1)

**Please guide users through this essential step:**

Before implementing any deliverable (code, prompt, template, documentation, config), check:

### 1. Does specification exist?

```bash
# Check for spec
ls specs/3-behaviors/[deliverable].spec.md 2>/dev/null ||
ls specs/3-contracts/[deliverable].spec.md 2>/dev/null ||
ls specs/2-strategy/[deliverable].spec.md 2>/dev/null
```

**Spec locations:**
- Behaviors (observable outcomes): `specs/3-behaviors/[deliverable].spec.md`
- Contracts (interfaces): `specs/3-contracts/[deliverable].spec.md`
- Strategy (cross-cutting): `specs/2-strategy/[deliverable].spec.md`

### 2. If NO spec exists: Guide to spec creation

**Pause and say:**
> "I need a specification before implementing. Let's create specs/3-behaviors/[deliverable].spec.md first."

**Then guide to Phase 1 (DESIGN):**
- For behaviors: "Use `.livespec/1-design/1b-define-behaviors.md`"
- For contracts: "Use `.livespec/1-design/1c-create-contracts.md`"
- For architecture/strategy: "Use `.livespec/1-design/1a-design-architecture.md`"

### 3. If YES spec exists: Verify & Implement

- Read specification completely
- Verify spec has:
  - Requirements section with [!] items
  - Validation criteria
  - Failure mode defined
- Implement what spec requires

### Common Patterns to Guide

**These all need specs first:**
- "Let's create a CHANGELOG" â†’ Guide to `specs/3-behaviors/changelog.spec.md` first
- "Add a README file" â†’ Guide to `specs/3-behaviors/readme.spec.md` first
- "Write a config template" â†’ Guide to spec creation first
- "This is obvious, no need for spec" â†’ Gently guide: spec needed for all deliverables

### Why This Matters

**Familiarity creates false confidence:**
- "Everyone knows what a CHANGELOG is" (but requirements vary)
- "README is standard" (but what should it contain?)
- "This is obvious" (assumptions cause drift)

**Real example:** LiveSpec's own CHANGELOG was implemented without spec (commit 40411e3), violating this principle. Even methodology creators make this mistake when familiarity overrides discipline.

**Your role:** Guide spec-first development, especially when user wants to skip it. Say: "I understand this seems obvious, but LiveSpec works best when we create a specification first. This prevents drift and ensures requirements are captured. Let's create the spec together - it will be quick."

---

## âš ï¸ CRITICAL: Pre-Implementation Verification

Before implementing ANY deliverable (code, prompt, template, documentation, config), verify:

1. â˜ **Behavior spec exists** for this deliverable
   - Check: `specs/3-behaviors/[deliverable].spec.md` exists
   - Spec has Requirements section with [!] items
   - Spec has Validation criteria
   - Spec has Failure Mode defined

2. â˜ **Tests exist** (if TDD project) and currently FAIL (RED)
   - Check: `tests/behaviors/[deliverable].test.ts` exists
   - Tests map to validation criteria (one test per criterion)
   - Tests currently fail (no implementation yet)

3. â˜ **Plan includes methodology steps** (not just implementation)
   - Plan includes spec creation (specific file path)
   - Plan includes test creation if TDD (specific file path)
   - Plan includes TDD cycle if applicable (RED â†’ GREEN â†’ REFACTOR)

**If any checkbox is unchecked â†’ STOP**

Guide user to Phase 1 (DESIGN):
- For behaviors: "Use `.livespec/1-design/1b-define-behaviors.md`"
- For contracts: "Use `.livespec/1-design/1c-create-contracts.md`"
- For architecture/strategy: "Use `.livespec/1-design/1a-design-architecture.md`"

## âš ï¸ WARNING: No "Plumbing" Exception

**ALL behavior changes require specifications.** There is no exception for "simple" or "infrastructure" work.

### Red Flags (Mental Categorization Errors)

These phrases indicate you may be skipping necessary specification:
- âŒ "Just wiring up [X]"
- âŒ "Just infrastructure"
- âŒ "Obviously simple"
- âŒ "This is just plumbing"
- âŒ "Everyone knows what [X] is"

### The Test

Ask yourself: **"If this breaks, does something stop working?"**

- **YES** â†’ It's a feature â†’ Needs specification â†’ Needs tests (if TDD)
- **NO** â†’ It's truly implementation detail â†’ May not need spec

### Real Example

LiveSpec's own MCP resource serving was categorized as "just wiring up resources" and implemented without specs. This violated the project's TDD methodology despite having full documentation. The agent had to create a detailed violation report.

**Lesson**: Familiarity creates false confidence. When in doubt, create a spec.

## Active Self-Check Questions

Before implementing, actively ask yourself:

### Spec-First Check
- **"Does this project require specs?"**
  - Check: Does `specs/` directory exist?
  - Check: Does `specs/workspace/constitution.spec.md` mention spec-first?

- **"Does a spec exist for what I'm implementing?"**
  - Check: `ls specs/3-behaviors/[deliverable].spec.md`
  - If NO â†’ Guide to Phase 1 (DESIGN)

### TDD Check
- **"Does this project use TDD?"**
  - Check: Read `specs/workspace/workflows.spec.md`
  - Look for: TDD cycle, test-first requirements

- **"Have I written tests before implementation?"**
  - Check: `ls tests/behaviors/[deliverable].test.ts`
  - Tests should exist and FAIL before implementation

### Methodology Compliance
- **"Am I following the documented methodology?"**
  - Check: Read `specs/workspace/` files
  - Verify: My plan matches documented workflows

- **"Have I verified my plan follows methodology?"**
  - Before user approval, check plan includes:
    - Spec creation (if needed)
    - Test creation (if TDD)
    - Methodology steps (not just implementation)

### Meta-Check
- **"Am I in execution mode bypassing methodology?"**
  - Warning sign: Focused on "completing the plan" rather than "following methodology"
  - Pause: Re-verify methodology compliance before continuing

---

## âš ï¸ REQUIRED: Visible Methodology Compliance

**You MUST output methodology checks during development - don't work silently.**

**Critical issue:** Silent compliance = invisible compliance = appears NOT compliant. User needs to SEE that you're following LiveSpec methodology.

### Before ANY Code Change

Output prerequisite verification:

```
ğŸ” Checking prerequisites for [feature/change]...
  âœ“ PURPOSE.md - [How this aligns with project purpose]
  âœ“ specs/3-behaviors/[feature].spec.md - [Exists/needs creation]
  âœ“ specs/workspace/patterns.spec.md - [Relevant patterns identified]
  [âš ï¸ if any missing] â†’ Guiding to Phase X first
```

**Example:**
```
ğŸ” Checking prerequisites for lazy file hashing...
  âœ“ PURPOSE.md - Aligns with "storage analysis" purpose
  âœ“ specs/3-behaviors/scanner.spec.md - Exists, needs update
  âœ“ specs/workspace/patterns.spec.md - Python conventions apply
```

### During Implementation

Output spec compliance:

```
ğŸ“‹ Implementing per specs/3-behaviors/[feature].spec.md:
  - Requirement: [specific requirement from spec]
  - Implementation: [how you're implementing it]
  - Validation: [how you'll verify it works]
```

**Example:**
```
ğŸ“‹ Implementing per specs/3-behaviors/scanner.spec.md:
  - Requirement: "Scanner aggregates node_modules directories"
  - Implementation: Adding node_modules to AGGREGATE_PATTERNS
  - Validation: Test scan skips node_modules in size calculations
```

### After Implementation

Output spec update needs:

```
ğŸ“ Spec alignment check...
  âœ“ specs/3-behaviors/[feature].spec.md - [Aligned/needs update]
  âš ï¸ specs/2-strategy/architecture.spec.md - [New component added - updating]

  [If updates needed] Updating specs now...
  âœ“ Updated [spec] to reflect [change]
```

**Example:**
```
ğŸ“ Spec alignment check...
  âš ï¸ scanner.spec.md diverged:
    - Code now uses --hash-files flag (defaults OFF)
    - Spec says "hashes files < 100MB" (always on)

  Updating specs/3-behaviors/scanner.spec.md:
    - Requirements: Added lazy hashing requirement
    - Validation: Added --hash-files flag test

  âœ“ Updated scanner.spec.md to reflect lazy hashing behavior
```

### Why This Matters

**Problem:** User can't tell if you're following methodology when you work silently.

**Solution:** Make compliance VISIBLE. Output what you're checking, what you're following, what you're updating.

**Not this:**
```
[Silently implements feature]
Done!
```

**This:**
```
ğŸ” Checking prerequisites...
  âœ“ All prerequisites met
ğŸ“‹ Implementing per scanner.spec.md...
  [implementation details]
ğŸ“ Updating specs to reflect changes...
  âœ“ scanner.spec.md updated
Done!
```

---

## Spec Update Protocol

**ALWAYS announce spec updates - don't update silently.**

### When Code Changes Behavior

1. **Identify affected specs** - List which specs need updates
2. **Describe changes** - What sections need modification
3. **Update specs** - Make the changes
4. **Confirm updates** - Output "âœ“ Updated [spec] to reflect [change]"

### Example Flow

```
Implementation complete. Checking spec alignment...

âš ï¸ scanner.spec.md diverged from implementation:
  - Code behavior: Uses --hash-files flag (defaults OFF)
  - Spec requirement: "Hashes files < 100MB" (always on)

  This is drift - spec no longer matches code.

Updating specs/3-behaviors/scanner.spec.md:
  - Requirements section: Added lazy hashing behavior
  - Validation section: Added --hash-files flag test
  - Rationale section: Added performance motivation

âœ“ Spec updated and aligned with implementation
âœ“ No other specs affected
```

### When Implementation Follows Spec

If implementation exactly follows existing spec:

```
âœ“ Implementation follows scanner.spec.md exactly
âœ“ No spec updates needed
```

**Never update code without announcing spec status.**

---

## âš ï¸ ACTIVE: Real-Time Learning Capture

**CRITICAL: When users say "remember this" or provide methodology guidance, immediately update specs and AGENTS.md - don't let learnings vanish after session.**

### Trigger Phrases

Watch for user instructions that indicate lasting process changes:

- "Remember this"
- "Always do X"
- "Never do Y"
- "From now on..."
- "In the future..."
- "Make sure to..."
- "Don't forget to..."
- "Add this to your process"

**These are NOT temporary instructions - they're permanent methodology updates.**

### MSL Minimalism at Capture Time

**CRITICAL: Check existing coverage BEFORE adding to workspace specs.**

**Before adding ANY requirement to workspace specs:**

1. **Search existing coverage**
   - Read relevant workspace spec completely
   - Check: Is this already stated (perhaps differently worded)?
   - Check: Does existing requirement implicitly cover this?
   - Use grep/search to find related terms

2. **Three response options** (in priority order):

   **Option A: Already covered** (preferred)
   - Point user to existing requirement
   - Say: "âœ“ This is already covered in [spec]:[line]"
   - Quote existing requirement
   - **Don't add** redundant requirement

   **Option B: Consolidate** (second choice)
   - Strengthen/clarify existing requirement
   - Show before/after
   - Keep it minimal (MSL test: would spec fail without this?)

   **Option C: Add new** (only if truly novel)
   - MSL test: Would spec fail without this? (If no â†’ don't add)
   - Keep concise (WHAT not HOW)
   - Add to appropriate section
   - Consider: Could this be inferred? (If yes â†’ don't add)

3. **Permission to refuse addition**
   - Saying "already covered" is GOOD, not obstructive
   - User satisfaction comes from spec quality, not spec size
   - Minimal specs are better specs

### The Protocol

When user provides learning to capture:

1. **Acknowledge immediately**
   ```
   ğŸ“ Capturing this in project methodology...
   ```

2. **Check existing coverage FIRST**
   - Identify target spec:
     - Process/workflow change â†’ `specs/workspace/workflows.spec.md`
     - Code pattern/convention â†’ `specs/workspace/patterns.spec.md`
     - Core principle â†’ `specs/workspace/constitution.spec.md`
     - Behavior-specific â†’ `specs/3-behaviors/[feature].spec.md`
   - Read target spec completely
   - Search for similar/related requirements (use grep if helpful)
   - Determine: Already covered / Consolidatable / Truly new

2a. **If already covered**:
   ```
   âœ“ This is already covered in specs/workspace/workflows.spec.md:45

   Existing requirement:
   "[Quote the existing requirement text]"

   â†’ No update needed - requirement already captured
   ```
   **STOP HERE** - Don't add, regeneration not needed

2b. **If consolidatable**:
   ```
   ğŸ“ Consolidating with existing requirement...

   âœ“ Updated specs/workspace/patterns.spec.md:32
     Before: "[Original requirement]"
     After: "[Strengthened requirement incorporating new learning]"

   Rationale: Consolidates [old concept] with [new learning]
   ```
   Continue to step 4 (regenerate AGENTS.md)

2c. **If truly new requirement**:
   ```
   ğŸ“ Adding new requirement (passed MSL minimalism test)...

   MSL test:
   - Would spec fail without this? YES - [explain failure mode]
   - Is this WHAT not HOW? YES - [confirm it's observable requirement]
   - Could this be inferred? NO - [confirm it's explicit need]
   ```
   Continue to step 3

3. **Update the spec** (only if 2c - truly new)
   - Add requirement to appropriate section
   - Mark as [!] if critical
   - Include rationale if not obvious
   - Keep concise (MSL: every word justified)
   - Announce the update:
   ```
   âœ“ Updated specs/workspace/workflows.spec.md:
     - Added: [new requirement]
     - Rationale: [why this matters]
     - MSL justified: [failure mode if missing]
   ```

4. **Regenerate AGENTS.md** (if workspace spec changed)
   - Guide user: "Use .livespec/4-evolve/4d-regenerate-agents.md to update AGENTS.md"
   - Explain: "This ensures future AI agents see this requirement"

5. **Confirm capture**
   ```
   âœ“ Learning captured in specs/workspace/[spec].spec.md
   âœ“ Will persist across sessions
   [If AGENTS.md needs update] âš ï¸ Run 4d-regenerate-agents to complete
   ```

### Example Scenarios

**User:** "Remember to always run tests before committing"

**You:**
```
ğŸ“ Capturing this in project methodology...

âœ“ Updated specs/workspace/workflows.spec.md:
  - Added: [!] Tests must pass before creating commits
  - Section: Commit Workflow
  - Validation: Pre-commit hook or manual test run required

âš ï¸ Next: Use .livespec/4-evolve/4d-regenerate-agents.md to update AGENTS.md
This ensures future AI agents see this requirement.

âœ“ Learning captured and will persist across sessions
```

---

**User:** "Always use lazy evaluation for expensive operations"

**You:**
```
ğŸ“ Capturing this in project methodology...

âœ“ Updated specs/workspace/patterns.spec.md:
  - Added: [!] Expensive operations use lazy evaluation
  - Context: Performance pattern
  - Rationale: Prevent premature computation, improve startup time

âš ï¸ Next: Use .livespec/4-evolve/4d-regenerate-agents.md to update AGENTS.md
This ensures future AI agents see this pattern.

âœ“ Learning captured and will persist across sessions
```

---

**User:** "From now on, document all architecture decisions in ADRs"

**You:**
```
ğŸ“ Capturing this in project methodology...

âœ“ Updated specs/workspace/workflows.spec.md:
  - Added: [!] Architecture decisions require ADR in docs/adr/
  - Section: Design Workflow
  - Format: Use ADR template from templates/adr.md
  - Validation: Architecture changes include ADR file

âš ï¸ Next: Use .livespec/4-evolve/4d-regenerate-agents.md to update AGENTS.md
This ensures future AI agents see this requirement.

âœ“ Learning captured and will persist across sessions
```

---

**User:** "Never modify database schemas without migration scripts"

**You:**
```
ğŸ“ Capturing this in project methodology...

âœ“ Updated specs/workspace/patterns.spec.md:
  - Added: [!] Database schema changes require migration scripts
  - Constraint: No direct schema modifications
  - Location: migrations/ directory
  - Validation: Schema change + migration script in same commit

âš ï¸ Next: Use .livespec/4-evolve/4d-regenerate-agents.md to update AGENTS.md
This ensures future AI agents see this constraint.

âœ“ Learning captured and will persist across sessions
```

### Primary Target: specs/workspace/

**Most learnings belong in workspace specs:**

- `workflows.spec.md` - Process steps, phase requirements, commit workflow
- `patterns.spec.md` - Code conventions, naming patterns, file organization
- `constitution.spec.md` - Core principles, values, priorities

**Occasionally other locations:**
- Behavior-specific guidance â†’ `specs/3-behaviors/[feature].spec.md`
- Strategic decision â†’ `specs/2-strategy/[domain].spec.md`
- New meta-process â†’ `specs/3-behaviors/processes/[process].spec.md`

### Why This Matters

**Problem:** User teaches AI agent important lesson during session, but learning vanishes when session ends. Next session, same mistake repeats.

**Solution:** Immediately capture learnings in specs. Future AI agents read specs and follow the guidance from the start.

**Not this:**
```
User: "Remember to always X"
You: "Got it! I'll do X."
[Session ends - learning lost]
[Next session - agent doesn't do X]
```

**This:**
```
User: "Remember to always X"
You:
  ğŸ“ Capturing this in project methodology...
  âœ“ Updated specs/workspace/workflows.spec.md
  âš ï¸ Next: Run 4d-regenerate-agents to update AGENTS.md
  âœ“ Learning captured and will persist
[Session ends - learning preserved]
[Next session - agent reads spec, does X automatically]
```

---

## Plan Review for Methodology Compliance

When presenting plans to users, include explicit methodology compliance verification:

### Before User Approval

Verify and report:

**â˜ Spec Creation**
- [ ] Does plan include creating/updating spec?
- [ ] Specific file path listed: `specs/3-behaviors/[feature].spec.md`
- [ ] If spec already exists, is it listed as "read and verify"?

**â˜ Test Creation (if TDD project)**
- [ ] Does plan include writing tests FIRST?
- [ ] Specific file path listed: `tests/behaviors/[feature].test.ts`
- [ ] TDD cycle explicit: "Write tests (RED) â†’ Implement (GREEN) â†’ Refactor"

**â˜ Methodology Steps vs Implementation Steps**
- [ ] Plan describes methodology process (spec â†’ test â†’ implement)
- [ ] Plan NOT just implementation steps ("create directory", "implement handlers")

**â˜ Workflow Reference**
- [ ] Plan references project's documented workflow
- [ ] Plan follows phases defined in `specs/workspace/workflows.spec.md`

### Report to User

**Before execution**, present compliance status:

```markdown
## Methodology Compliance Check

â˜ Specification: [EXISTS/WILL CREATE: path] / [MISSING - need to create first]
â˜ Tests: [EXISTS/WILL CREATE: path] / [N/A - not TDD project] / [MISSING - need to create first]
â˜ Workflow: Follows [reference specific workflow from specs/workspace/]

[If non-compliant: "I need to revise this plan to include [missing items] first."]
[If compliant: "This plan follows project methodology. Ready to proceed with your approval."]
```

### After User Approval

Before beginning execution, re-verify one final time that all methodology artifacts are in place or explicitly included in approved plan.

---

## Quick Start (80% of Cases)

### New Project
```bash
# 1. Copy LiveSpec methodology
cp -r livespec/prompts .livespec

# 2. Create specs structure
mkdir -p specs/{workspace,1-requirements/{strategic,functional},2-strategy,3-behaviors,3-contracts}

# 3. Create PURPOSE.md
echo "# Project Purpose

## Why This Exists
[Problem this project solves]

## What Success Looks Like
[Measurable success criteria]" > PURPOSE.md

# 4. Start Phase 0
# "Use .livespec/0-define/0a-setup-workspace.md"
```

### Existing Project
```bash
# Extract specifications from code
# "Use .livespec/4-evolve/4b-extract-specs.md to document this codebase"
```

## Decision Tree

```
What do you need to do?
â”‚
â”œâ”€ **New project?**
â”‚  â””â”€ Phase 0: Use .livespec/0-define/0a-setup-workspace.md
â”‚
â”œâ”€ **Existing project without specs?**
â”‚  â””â”€ Phase 4: Use .livespec/4-evolve/4b-extract-specs.md
â”‚
â”œâ”€ **Code and specs drifted?**
â”‚  â””â”€ Phase 4: Use .livespec/4-evolve/4a-detect-drift.md
â”‚
â”œâ”€ **Need to design new feature?**
â”‚  â””â”€ Phase 1: Use .livespec/1-design/1a-design-architecture.md
â”‚
â”œâ”€ **Ready to implement?**
â”‚  â””â”€ Phase 2: Use .livespec/2-build/2a-implement-from-specs.md
â”‚
â””â”€ **Need validation?**
   â””â”€ Phase 3: Use .livespec/3-verify/3a-run-validation.md
```

## The 5 Phases

### Phase 0: DEFINE
Establish problem space and constraints.

**When**: Starting new project or documenting existing one
**Entry**: Project idea or codebase
**Exit**: Problem, constraints, workspace defined
**Outputs**: PURPOSE.md, specs/constraints.spec.md, specs/workspace/
**Key Prompt**: `0a-setup-workspace.md`

### Phase 1: DESIGN
Design solution architecture.

**When**: After problem clear, before implementation
**Entry**: Problem and constraints defined
**Exit**: Architecture and contracts specified
**Outputs**: specs/3-behaviors/, specs/3-contracts/
**Key Prompt**: `1a-design-architecture.md`

### Phase 2: BUILD
Implement the solution.

**When**: After design approved
**Entry**: Design specifications complete
**Exit**: Implementation matches specifications
**Outputs**: Code + tests satisfying specs
**Key Prompt**: `2a-implement-from-specs.md`

### Phase 3: VERIFY
Validate solution meets requirements.

**When**: After implementation complete
**Entry**: Implementation done
**Exit**: All behaviors validated
**Outputs**: Test results, validation reports
**Key Prompt**: `3a-run-validation.md`

### Phase 4: EVOLVE
Keep specs and code synchronized (continuous).

**When**: Ongoing throughout development
**Entry**: System in production or active development
**Exit**: Continuous (loop back to other phases as needed)
**Outputs**: Updated specifications, drift reports
**Key Prompt**: `4a-detect-drift.md`

## MSL Format Quick Reference

All specifications use [MSL (Markdown Specification Language)](https://github.com/chrs-myrs/msl-specification):

```markdown
---
criticality: CRITICAL | IMPORTANT
failure_mode: [What breaks without this]
---

# [Feature/Component Name]

## Requirements
- [!] [Concise description of WHAT is required, not HOW]
  - [Testable criterion 1]
  - [Testable criterion 2]
  - [Testable criterion 3]
```

**That's it.** Title, frontmatter, Requirements. Keep specifications minimal.

## Folder Structure Pattern

```
your-project/
â”œâ”€â”€ PURPOSE.md              # Why this exists, what success looks like
â”‚
â”œâ”€â”€ .livespec/              # Copied from livespec/dist/
â”‚   â”œâ”€â”€ 0-define/
â”‚   â”œâ”€â”€ 1-design/
â”‚   â”œâ”€â”€ 2-build/
â”‚   â”œâ”€â”€ 3-verify/
â”‚   â”œâ”€â”€ 4-evolve/
â”‚   â””â”€â”€ utils/              # Utility prompts
â”œâ”€â”€ standard/               # MSL metaspecs and conventions
â””â”€â”€ templates/              # Workspace spec starter files
    â””â”€â”€ workspace/

specs/
â”œâ”€â”€ workspace/              # HOW you build (process)
â”‚   â”œâ”€â”€ constitution.spec.md
â”‚   â”œâ”€â”€ patterns.spec.md
â”‚   â””â”€â”€ workflows.spec.md
â”‚
â”œâ”€â”€ 1-requirements/         # High-level requirements
â”œâ”€â”€ 2-strategy/             # Technical approach
â”œâ”€â”€ 3-behaviors/            # Observable outcomes
â””â”€â”€ 3-contracts/            # Interface definitions
```

## Multi-Domain Organization (v2.1+)

**Key insight:** behaviors/ and contracts/ abstractions work across ALL domains. Use subfolders for semantic organization.

### Domain-Agnostic Abstractions

**behaviors/** = Observable outcomes from any perspective:
- Software: "System authenticates users"
- Governance: "Only authorized entities access resources" (policy)
- Operations: "Backups complete daily" (service)
- Planning: "Feature meets success criteria" (requirement)

**contracts/** = Interface definitions of any kind:
- Software: API contracts (`GET /users/{id}`)
- Governance: Process contracts (procedures)
- Operations: Operational contracts (runbooks)
- Planning: Workflow contracts (delivery processes)

### Organization Patterns by Domain

**Software projects:**
```
specs/
â”œâ”€â”€ workspace/           # How we work
â”œâ”€â”€ 3-behaviors/
â”‚   â”œâ”€â”€ user-features/  # User-facing behaviors
â”‚   â”‚   â”œâ”€â”€ authentication.spec.md
â”‚   â”‚   â””â”€â”€ authorization.spec.md
â”‚   â””â”€â”€ system/         # System behaviors
â”‚       â””â”€â”€ caching.spec.md
â”œâ”€â”€ 3-contracts/
â”‚   â””â”€â”€ api/v1/         # API contracts
â”‚       â””â”€â”€ users-api.yaml
â””â”€â”€ 2-strategy/         # Cross-cutting decisions
    â”œâ”€â”€ architecture.spec.md
    â””â”€â”€ logging.spec.md
```

**Governance projects:**
```
specs/
â”œâ”€â”€ workspace/           # How we work
â”œâ”€â”€ 3-behaviors/
â”‚   â””â”€â”€ policies/       # Policy behaviors
â”‚       â”œâ”€â”€ access-control.spec.md
â”‚       â””â”€â”€ data-protection.spec.md
â”œâ”€â”€ 3-contracts/
â”‚   â””â”€â”€ procedures/     # Process contracts
â”‚       â””â”€â”€ access-review.spec.md
â””â”€â”€ 2-strategy/         # Cross-cutting decisions
    â””â”€â”€ security-posture.spec.md
```

**Operations projects:**
```
specs/
â”œâ”€â”€ workspace/           # How we work
â”œâ”€â”€ 3-behaviors/
â”‚   â””â”€â”€ services/       # Service behaviors
â”‚       â”œâ”€â”€ backup.spec.md
â”‚       â””â”€â”€ monitoring.spec.md
â”œâ”€â”€ 3-contracts/
â”‚   â””â”€â”€ runbooks/       # Operational contracts
â”‚       â”œâ”€â”€ incident-response.spec.md
â”‚       â””â”€â”€ deployment.spec.md
â””â”€â”€ 2-strategy/         # Cross-cutting decisions
    â””â”€â”€ infrastructure.spec.md
```

**Hybrid projects:**
```
specs/
â”œâ”€â”€ workspace/             # How we work
â”œâ”€â”€ 3-behaviors/
â”‚   â”œâ”€â”€ user-features/    # Software
â”‚   â”œâ”€â”€ policies/         # Governance
â”‚   â””â”€â”€ services/         # Operations
â”œâ”€â”€ 3-contracts/
â”‚   â”œâ”€â”€ api/              # Software
â”‚   â”œâ”€â”€ procedures/       # Governance
â”‚   â””â”€â”€ runbooks/         # Operations
â””â”€â”€ 2-strategy/           # Cross-cutting (all domains)
    â”œâ”€â”€ architecture.spec.md
    â”œâ”€â”€ logging.spec.md
    â””â”€â”€ security.spec.md
```

See `docs/domain-organization.md` for comprehensive patterns.

---

## Meta-Process Specs Pattern

**When specs govern creation of documentation (not system behavior):**

### What Are Meta-Process Specs?

Specs that define HOW to create other documentation or artifacts:
- `investigation.spec.md` - How to document investigations
- `refactoring.spec.md` - How to document refactoring decisions
- `adr.spec.md` - How to write Architecture Decision Records
- `incident.spec.md` - How to document production incidents

**Key characteristic:** These specs create a PATTERN for governed documentation instances.

### Where They Belong

**Option A (Recommended): behaviors/processes/**

Place in `specs/3-behaviors/processes/[process].spec.md`

**Rationale:** Following the process is observable behavior. The process produces observable artifacts.

**Example structure:**
```
specs/
â”œâ”€â”€ 3-behaviors/
â”‚   â”œâ”€â”€ user-features/        # User-facing behaviors
â”‚   â”œâ”€â”€ system/               # System behaviors
â”‚   â””â”€â”€ processes/            # Meta-process behaviors
â”‚       â”œâ”€â”€ investigation.spec.md
â”‚       â”œâ”€â”€ refactoring.spec.md
â”‚       â””â”€â”€ incident.spec.md
```

**Option B: workspace/processes/**

Place in `specs/workspace/processes/[process].spec.md`

**Rationale:** Process governs how team works (workflow-level governance).

**Use when:** Process is purely team/workflow governance with no project artifacts.

**Decision criteria:**
- Process creates project artifacts â†’ `behaviors/processes/`
- Process governs team workflow only â†’ `workspace/processes/`

### Governed Documentation Pattern

Meta-process specs govern "governed documentation" - documentation that must conform to spec structure:

**Spec (reusable):** `specs/3-behaviors/processes/investigation.spec.md`
**Instances (governed):** `investigations/001-docker-wsl/problem.md`, `findings.md`

**Relationship:**
- Spec defines requirements for ALL instances
- Instances MUST conform to spec structure
- Instances are NOT specs themselves (they're data/documentation)

**Example from Hoardwick:**
```
specs/3-behaviors/processes/
â””â”€â”€ investigation.spec.md          # Defines investigation requirements

investigations/
â”œâ”€â”€ 001-docker-wsl-growth/
â”‚   â”œâ”€â”€ problem.md                 # Conforms to investigation.spec.md
â”‚   â”œâ”€â”€ findings.md                # Conforms to investigation.spec.md
â”‚   â””â”€â”€ data/                      # Raw investigation data
â”œâ”€â”€ 002-wsl-vhdx-bloat/
â”‚   â””â”€â”€ ...                        # Also conforms to spec
â””â”€â”€ LEARNINGS.md                   # Not governed (just documentation)
```

### Circular Dependencies (Continuous Improvement)

Meta-process specs often have feedback loops:

```
Investigations â†’ Learnings â†’ Spec updates â†’ Better investigations
```

**This is GOOD.** Continuous improvement requires feedback loops.

**Document in spec's Rationale section:**
```markdown
## Rationale

This spec evolves based on investigation learnings.
See investigations/LEARNINGS.md for feedback loop documentation.
Spec improvements feed back into better investigation outcomes.
```

**Convergence:** Specs should stabilize over time as patterns mature, but expect evolution as learnings accumulate.

### Template Pattern

Meta-process specs follow a common pattern:

```markdown
---
criticality: IMPORTANT
failure_mode: [What happens without structured process]
pattern: meta-process
---

# [Process Name] Behavior

## Requirements

### [Artifact] Structure
- [!] Each [artifact] lives in [location pattern]
  - Naming convention
  - Required files/sections

### [Artifact] Format
- [!] Must define: [required sections]
- [!] Must be measurable/verifiable

### Lifecycle
- [!] States: [valid states]
- [!] State tracking: [mechanism]

## Rationale

[Why this process exists]
[Feedback loop if applicable]

## Validation

[How to verify conformance]
```

See `dist/templates/processes/meta-process.spec.md.template` for full template.

---

## Spec Evolution

**Live specs only. Git is the history.**

### One Source of Truth Principle

- `specs/` directory contains ONLY current, active specs
- No `_old`, `_v2`, `_deprecated`, or `_backup` files
- No deprecated specs (delete them, git preserves history)
- No version numbers in filenames

**Rationale:** Multiple versions create:
- Risk of implementing from wrong spec
- Confusion about which spec is authoritative
- Drift between versions
- Complexity that LiveSpec exists to prevent

### Evolving Specs In Place

**When spec needs updates:**

1. **Update the existing spec directly**
   - Edit the current spec file in place
   - Git commit captures the change
   - Commit message explains what and why

2. **If filename should change:**
   - Create new spec with better name
   - Update all frontmatter references (guided-by, satisfies, etc.)
   - DELETE old spec in same commit
   - Git preserves old spec in history

**Example evolution:**
```bash
# Bad (creates duplicate)
cp investigation.spec.md investigation-v2.spec.md

# Good (evolves in place)
# Edit investigation.spec.md directly
git commit -m "Update investigation.spec.md: Add learnings feedback loop requirement"

# Good (rename if needed)
git mv investigation.spec.md root-cause-investigation.spec.md
# Update frontmatter in other specs that reference it
git commit -m "Rename investigation spec for clarity"
```

### Breaking Changes to Specs

**If change would break existing implementations:**

1. Update implementation AND spec together in same commit
2. Commit message explains what changed and why
3. No deprecation period - just update

**Example commit message:**
```
Update scanner behavior: Switch to lazy hashing

- Updated scanner.spec.md: Added --hash-files flag requirement
- Updated scan.py: Implemented lazy hashing behavior
- Breaking change: Default behavior now skips hashing

Rationale: 551k files hashed caused 6-hour scans.
Lazy hashing reduces scan time to <1 hour.
```

### Viewing Spec History

**To see spec evolution:**
```bash
# View all changes to spec
git log -- specs/3-behaviors/scanner.spec.md

# Compare current vs specific version
git diff abc123 -- specs/3-behaviors/scanner.spec.md

# View spec at specific point in time
git show abc123:specs/3-behaviors/scanner.spec.md
```

**Git provides:**
- What changed (diff)
- When changed (commit timestamp)
- Why changed (commit message)
- Who changed (commit author)

**No frontmatter versioning needed.** Git is the version control system.

### When Spec Becomes Obsolete

**If spec no longer applies:**

1. DELETE the spec file
2. Remove references from other specs
3. Commit with clear explanation

**Example:**
```bash
git rm specs/3-behaviors/manual-backup.spec.md
# Update any specs that referenced it
git commit -m "Remove manual-backup.spec.md: Replaced by automated-backup.spec.md"
```

**Git preserves the deleted spec.** If needed later, retrieve from history:
```bash
git checkout abc123 -- specs/3-behaviors/manual-backup.spec.md
```

### No Deprecated Specs

**Never mark specs as deprecated and leave them in specs/ directory.**

**Bad:**
```yaml
---
status: deprecated
replaced-by: new-spec.spec.md
---
```

**Good:**
```bash
# Delete old spec
git rm old-spec.spec.md

# Update references in commit message
git commit -m "Remove old-spec.spec.md

Replaced by: new-spec.spec.md
Migration: [if applicable, how to migrate]"
```

**Rationale:** Deprecated specs create confusion and risk. One source of truth means exactly one - not one current + several deprecated.

---

## Spec vs Governed Documentation

**Decision tree for "should this be a spec?"**

```
Does it define requirements for MULTIPLE instances?
â”œâ”€ YES â†’ It's a SPEC
â”‚  â””â”€ Example: investigation.spec.md (governs ALL investigations)
â”‚
â””â”€ NO â†’ Does it define requirements for ONE instance?
   â”œâ”€ YES â†’ It's GOVERNED DOCUMENTATION
   â”‚  â””â”€ Example: problem.md (one investigation's requirements)
   â”‚  â””â”€ Follows pattern from governing spec
   â”‚
   â””â”€ NO â†’ It's just DOCUMENTATION
      â””â”€ Example: LEARNINGS.md (captures insights, no requirements)
      â””â”€ Example: QUEUE.md (tracks state, no requirements)
```

### Examples

| Artifact | Type | Rationale |
|----------|------|-----------|
| `investigation.spec.md` | SPEC | Defines requirements for ALL investigations |
| `001-docker/problem.md` | GOVERNED DOC | One investigation's requirements, follows spec |
| `001-docker/findings.md` | GOVERNED DOC | One investigation's findings, follows spec |
| `investigations/LEARNINGS.md` | DOCUMENTATION | Captures insights across investigations, no requirements |
| `investigations/QUEUE.md` | DOCUMENTATION | Tracks investigation state, no requirements |
| `patterns.spec.md` | SPEC | Defines requirements for all code |
| `README.md` | DOCUMENTATION | Explains project, no requirements |

### When Uncertain

**Ask:** "If there were 10 of these, would they all follow the same structure?"

- YES â†’ Create a spec defining that structure
- NO â†’ Just create the documentation

**Example:** Creating first investigation:
- First instinct: Just create `investigations/001-problem.md`
- Better: Create `investigation.spec.md` first, defining pattern for ALL investigations
- Result: Future investigations consistent, pattern reusable

---

## Folder Organization Decision Tests

**Critical for proper spec placement:**

**workspace/ test:** "Could I copy this spec to ANY project?"
- YES â†’ workspace/ (portable process)
- NO â†’ Check strategy/ or behaviors/

**strategy/ test:** "Does this apply across the whole product?"
- YES â†’ strategy/ (cross-cutting technical decision)
- NO â†’ Check behaviors/

**behaviors/ test:** "Is this an observable outcome users/system must exhibit?"
- YES â†’ behaviors/ (what system does)
- NO â†’ Re-examine classification

**Common Mistakes:**
- âŒ "API returns JSON" â†’ NOT workspace (product-specific) â†’ strategy/
- âŒ "Use 4-space indentation" â†’ NOT strategy (not critical) â†’ workspace/ (if it matters)
- âŒ "System authenticates users" â†’ NOT strategy (observable) â†’ behaviors/

**Correct Examples:**
- âœ… "Use MSL format for all specs" â†’ workspace/patterns.spec.md (applies to any project)
- âœ… "API responses must be JSON" â†’ strategy/architecture.spec.md (product-wide decision)
- âœ… "System authenticates users via OAuth" â†’ behaviors/authentication.spec.md (observable outcome)

## Essential Templates

### Workspace Constitution
```markdown
# [Project Name] Development Constitution

**Criticality**: CRITICAL
**Failure Mode**: Development becomes inconsistent

## Specification
[3-5 core development principles for this project]

## Validation
- [Observable behaviors demonstrating adherence]
```

### Behavior Specification
```markdown
# [Feature Name]

**Criticality**: CRITICAL | IMPORTANT
**Failure Mode**: [Impact if missing]

## Specification
[Observable behavior the system must exhibit]

## Validation
- [How to verify this works]
- [Edge cases to test]
```

### API Contract
```markdown
# [Endpoint Name]

**Criticality**: CRITICAL
**Failure Mode**: [Integration breaks]

## Specification
[Request/response format, authentication, rate limits]

## Validation
- [Valid requests succeed]
- [Invalid requests fail appropriately]
```

### Extracted Specification (Low Confidence)
```markdown
---
extracted_from:
  - src/cache/redis.py
  - src/cache/invalidation.py
extracted_date: 2025-10-06
confidence: LOW
requires_validation: true
extraction_reason: "Inferred from implementation, no tests found for invalidation behavior"
---

# Cache Invalidation

**Criticality**: IMPORTANT (estimated)
**Failure Mode**: Stale data served to users (inferred)

## Specification

âš ï¸ **EXTRACTION NOTES**: TTL constant found in code. No tests for invalidation behavior. Actual requirement unclear.

System appears to invalidate Redis cache entries after 1 hour TTL.

## Validation

**Status**: EXTRACTED - Requires validation

- [?] Cache TTL is 1 hour (constant found: CACHE_TTL = 3600)
- [?] Cache invalidates on entity updates (invalidation code present)
- [?] Cache misses fetch from database (fallback logic exists)

**Review checklist:**
- [ ] Confirm 1-hour TTL is requirement (vs implementation detail)
- [ ] Verify invalidation triggers
- [ ] Add test coverage for cache behavior
```

**Use this template when:**
- Extracting specs from code (Phase 4b)
- Confidence is LOW or MEDIUM
- No tests exist for the behavior
- Multiple interpretations possible

**Promote to standard spec when validated:** Remove extraction metadata, add standard frontmatter (derives_from, satisfies).

## Core Principles

**From specs/workspace/constitution.spec.md (in priority order):**

### 1. Specs Before Implementation
- Every deliverable requires specification before implementation
- AI agents check for spec existence and guide to Phase 1 (DESIGN) if missing
- Applies to all deliverables (code, prompts, templates, documentation, configs)
- Even "obvious" deliverables need specs (CHANGELOG mistake in commit 40411e3)
- See "âš ï¸ CRITICAL: Spec-First Guidance" section above for detailed workflow

### 2. MSL Minimalism
- Specs justify their existence (would system fail without this?)
- Specify WHAT, not HOW
- Only CRITICAL or IMPORTANT requirements
- Trust implementers for details

### 3. Dogfooding
- LiveSpec uses its own methodology
- Repository has specs/ and prompts/
- No custom tooling required

### 4. Simplicity Over Features
- No custom tooling (works with file operations and AI prompts only)
- Standard markdown format, standard folder structure
- Don't over-prescribe implementation details
- Define edges, not paths
- Innovation happens in unspecified spaces

### 5. Living Documentation
- Specs evolve continuously with code
- Phase 4 (EVOLVE) runs regularly to detect drift
- Extract new behaviors as they emerge
- Update specs alongside code changes

### 6. Governance Framework Awareness
- LiveSpec is specialized for governance/methodology documentation
- Patterns demonstrated here apply to governance domain specifically
- Extensions documented as domain-specific, not universal patterns

## Project Taxonomy (Check First)

**CRITICAL**: Before creating ANY files, check `specs/workspace/taxonomy.spec.md`

This project-level classification defines three essential boundaries:

1. **Project Domain**: What type of project this is
   - Software (code â†’ executables)
   - Generation (data â†’ tailored deliverables like CVs, reports)
   - Planning (research â†’ decisions/analyses)
   - Documentation (specs â†’ published docs)
   - Governance (methodology â†’ framework)
   - Hybrid (combination of above)

2. **Workspace Scope**: What's portable methodology vs product-specific
   - Explicitly lists workspace/ contents (typically: constitution, patterns, workflows, taxonomy)
   - Explicitly states what's NOT workspace with examples
   - Test: "Could I use this in ANY project?" â†’ YES = workspace/, NO = elsewhere

3. **Specs Boundary**: Declares "specs/ = specifications only"
   - No user data in specs/ (data â†’ data/ folder)
   - No research materials in specs/ (research â†’ research/ folder)
   - No generated artifacts in specs/ (outputs â†’ generated/ or var/generated/)
   - specs/ defines WHAT to do, never contains actual data or outputs

**Common mistakes taxonomy prevents**:
- âŒ Putting product features in workspace/ (fails portability test)
  - Example: "job-applications.spec.md" in workspace/ â†’ Should be 3-behaviors/processes/
- âŒ Putting user data in specs/ (violates specs boundary)
  - Example: CV details in specs/ â†’ Should be in data/ folder
- âŒ Creating files without checking project classification
  - Always check taxonomy FIRST, then apply patterns

**Decision order when creating files**:
1. Read `specs/workspace/taxonomy.spec.md` (primary reference)
2. Apply classification rules from taxonomy
3. Check `specs/workspace/patterns.spec.md` for naming conventions
4. If still unclear, use portability test ("works in any project?" â†’ workspace/)

**See Reference Library**: `taxonomy.spec.md` metaspec for complete framework

## Constraints (Critical Boundaries)

### Agent Agnostic
Works with any AI coding agent (Claude, Copilot, Cursor, etc.). Same structure produces effective results across 3+ agents.

### Manual Adoption
Simple enough to adopt without custom tooling. Users can set up with standard file operations and AI prompts only.

### MSL Minimalism
All specifications follow MSL principles. Specifications cannot be further reduced without losing essential information.

### No Framework Lock-in
Pure information architecture. Specs are readable markdown, folder structure is standard, no custom parsers required.

### Testable Behaviors
All behaviors are observable and verifiable. Every specification includes concrete validation criteria.

## Specification Dependencies

LiveSpec specs form a **dependency graph**, not a hierarchy:
- **Vertical**: PURPOSE â†’ requirements (HLR) â†’ design â†’ implementation â†’ code
- **Horizontal**: Workspace (process) applies across all levels

### Dependency Structure

**Key insight:** Implementation specs have **dual linkage** (not pure cascade):

```
PURPOSE.md (Why - Vision)
  â†“ defines
specs/1-requirements/strategic/outcomes.spec.md (What - High-Level Requirements)
  â†“ derives-from                           â†“ derives-from
specs/2-strategy/architecture.spec.md â†â”€â”€â”€â”€â”€â”€â”
  â†“ guided-by (HOW)                          â”‚
  â”‚                                          â”‚
  â”œâ”€â”€â†’ specs/3-behaviors/*.spec.md â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚      â†‘ satisfies (WHAT)
  â”‚      â”‚
  â””â”€â”€â”€â”€â”€â”€â”˜
         â†“ implemented-by
      code (Implementation)
```

**Dual relationships in implementation specs:**
- **satisfies** (vertical): Links directly to requirements (WHAT business value)
- **guided-by** (horizontal): Follows strategic approach (HOW implemented)

**Example:**
```yaml
# specs/3-behaviors/payment-processing.spec.md
---
satisfies:
  - specs/1-requirements/functional/transaction-accuracy.spec.md  # WHAT
guided-by:
  - specs/2-strategy/api-design.spec.md                          # HOW
---
```

**Orthogonal (applies everywhere):**
- `specs/workspace/` - Process governing all development

### Frontmatter Convention

Specs declare dependencies via YAML frontmatter:

```yaml
---
derives-from:
  - PURPOSE.md
  - specs/problem.spec.md
governed-by:
  - specs/constraints.spec.md
satisfies:
  - specs/problem.spec.md
---
```

**Fields:**
- `derives-from` - Parent specs this is based on
- `governed-by` - Boundaries this must respect
- `satisfies` - Requirements this fulfills (vertical - WHAT)
- `guided-by` - Strategies that guide this spec (horizontal - HOW)
- `supports` - What this spec enables
- `applies_to` - Scope (for workspace specs)

### Impact Detection

When specs change, trace dependencies:

**Upward (validate):** Does change still align with parents?
```bash
# Check frontmatter
grep "derives-from\|governed-by" specs/changed-spec.spec.md
```

**Downward (propagate):** What derives from this?
```bash
# Find children
grep -r "derives-from.*changed-spec" specs/
```

**Common impacts:**
| Changed | Check Upward | Check Downward |
|---------|--------------|----------------|
| PURPOSE.md | None (root) | requirements.spec.md, constraints.spec.md |
| requirements.spec.md | PURPOSE.md | architecture.spec.md, behaviors/ |
| architecture.spec.md | requirements.spec.md, constraints.spec.md | prompts/, behaviors/ |
| behaviors/*.spec.md | architecture.spec.md | Code |

See `specs/DEPENDENCIES.md` for complete traceability reference.

### âš ï¸ Critical: Dual Linkage Pattern

**Common mistake:** Assuming pure cascade (Requirements â†’ Strategy â†’ Behaviors)

**âŒ Wrong mental model:**
```
Behaviors satisfy strategy, strategy satisfies requirements
```

**âœ… Correct model:**
```
Behaviors SATISFY requirements (direct link - WHAT they achieve)
Behaviors GUIDED-BY strategy (horizontal influence - HOW they do it)
```

**Why this matters:**
- Enables rapid rebuild: Same requirements, different strategy, new implementation
- Technology-agnostic requirements: Requirements don't change when replatforming
- Clear traceability: What business value (satisfies) vs how implemented (guided-by)

**Real example confusion:** Agent sees behavior linking directly to requirement and flags as "missing strategy layer." This is CORRECT behavior - behaviors should satisfy requirements directly while being guided by strategy.

**See full explanation:** `specs/2-strategy/three-layer-architecture.spec.md` (section: "Dual Linkage Pattern")

## Common Anti-Patterns

âŒ **Skipping Phase 0**
```
Bad:  Jump straight to coding
Good: Create PURPOSE.md and workspace specs first
```

âŒ **Over-specification**
```
Bad:  "Button must be exactly 120px wide with #007bff color"
Good: "Submit button must be clearly visible"
```

âŒ **Ignoring Drift**
```
Bad:  Let specs and code diverge over months
Good: Run Phase 4 drift detection weekly/before releases
```

âŒ **Wrong Criticality**
```
Bad:  Everything marked CRITICAL
Good: Only truly critical requirements marked CRITICAL
```

## Bidirectional Linking

LiveSpec uses YAML frontmatter for bidirectional links:

**In prompts:**
```markdown
---
implements: specs/3-behaviors/prompts/0a-setup-workspace.spec.md
---
```

**In specs:**
```markdown
---
specifies: prompts/0-define/0a-setup-workspace.md
---
```

This enables AI agents to navigate between prompts and their specifications.

## MSL Alignment (v2.2+)

**LiveSpec uses MSL frontmatter conventions** for semantic precision and ecosystem interoperability.

### Field Semantics

| Field | Meaning | Example Usage |
|-------|---------|---------------|
| `derives-from:` | "I was created from this source" | spec derives-from: PURPOSE.md |
| `governed-by:` | "I must follow these rules/metaspecs" | spec governed-by: behavior-metaspec |
| `implements:` | "I am code/content satisfying this spec" | prompt implements: prompt.spec.md |
| `specifies:` | "I define what these files should do" | spec specifies: prompt.md |
| `extends:` | "I am specialized type of parent" (MSL core) | mobile-api extends: api-base |
| `supports:` | "These depend on me" (LiveSpec extension) | outcomes supports: architecture |

### Field Examples

**Prompt files**:
```yaml
---
implements: specs/3-behaviors/prompts/setup.spec.md
---
```

**Specification files**:
```yaml
---
derives-from: PURPOSE.md
governed-by: .livespec/standard/metaspecs/behavior.spec.md
---
```

### Why This Matters

- **Semantic clarity**: `implements:` precisely describes relationship
- **MSL ecosystem**: Unified vocabulary across MSL and LiveSpec
- **Hyphen consistency**: Matches MSL convention
- **AI predictability**: Agents trained on MSL understand field meanings

### Migration

Projects using old field names (`spec:`, `constrained_by:`, `derives_from:`) should migrate.

See `docs/msl-alignment-migration.md` for migration script and instructions.

## When to Fetch Full Prompts

Cache this document, but fetch full prompts when you need:

| Need | Fetch | When |
|------|-------|------|
| Setup workspace | `.livespec/0-define/0a-setup-workspace.md` | New project |
| Define problem | `.livespec/0-define/0b-define-problem.spec.md` | Problem unclear |
| Identify constraints | `.livespec/0-define/0c-identify-constraints.md` | Need boundaries |
| Design architecture | `.livespec/1-design/1a-design-architecture.md` | Before implementation |
| Define behaviors | `.livespec/1-design/1b-define-behaviors.md` | Specify features |
| Create contracts | `.livespec/1-design/1c-create-contracts.md` | API/data interfaces |
| Implement | `.livespec/2-build/2a-implement-from-specs.md` | Building features |
| Create tests | `.livespec/2-build/2b-create-tests.md` | Validating code |
| Run validation | `.livespec/3-verify/3a-run-validation.md` | Testing completeness |
| Acceptance review | `.livespec/3-verify/3b-acceptance-review.md` | Stakeholder approval |
| Detect drift | `.livespec/4-evolve/4a-detect-drift.md` | Periodic sync check |
| Extract specs | `.livespec/4-evolve/4b-extract-specs.md` | Existing codebase |
| Sync complete | `.livespec/4-evolve/4c-sync-complete.md` | Confirm alignment |
| Regenerate agents | `.livespec/4-evolve/4d-regenerate-agents.md` | Update AGENTS.md |
| Validate extractions | `.livespec/4-evolve/4e-validate-extractions.md` | Review low-confidence specs |
| **Upgrade LiveSpec** | `.livespec/utils/upgrade-methodology.md` | **New version released** |

**Important for upgrades:** The upgrade-methodology.md prompt includes mandatory pre-flight checks and proof-of-work requirements (like spec-first enforcement). You must:
- Actually clone the LiveSpec repository (show git clone output)
- Create backup and prove it exists (show ls output)
- Run self-validation tests and show results
- Cannot fake the process - evidence required for each phase

## Workspace Specs Guide AI

The three workspace specs define HOW this specific project is built:

- **constitution.spec.md** - Development principles and governance
- **patterns.spec.md** - Code and specification patterns
- **workflows.spec.md** - Development process workflows

**Always read workspace specs first** when working on a project. They contain project-specific conventions and constraints.

## Version Tracking and Customizations (v2.1+)

### Version Tracking Files

Projects using LiveSpec v2.1+ include version tracking for safe upgrades:

- **`.livespec-version`** - Installed LiveSpec version (enables upgrade detection)
- **`customizations.yaml`** - Tracks user customizations for AI-assisted merges

### When AI Should Update customizations.yaml

AI agents should update `customizations.yaml` when users:

**Modify prompts:**
```yaml
prompts:
  modified:
    - path: prompts/0-define/0a-setup-workspace.md
      reason: "Added governance-specific workspace setup steps"
      modified_at: 2025-10-08
```

**Add custom prompts:**
```yaml
prompts:
  added:
    - path: prompts/custom/governance-review.md
      reason: "Custom governance review workflow"
      added_at: 2025-10-08
```

**Add custom templates:**
```yaml
templates:
  added:
    - path: templates/custom/governance-policy.spec.md.template
      reason: "Organization-specific policy template"
      added_at: 2025-10-08
```

**Protect paths from upgrades:**
```yaml
never_overwrite:
  - prompts/custom/
```

### Upgrade Workflow

Use `.livespec/utils/upgrade-methodology.md` for AI-assisted upgrades:
- AI reads `customizations.yaml` to identify custom vs canonical files
- Progressive merge: auto-update safe files, interactive review for customized files
- AI explains changes, helps merge conflicts intelligently
- Backup created before upgrade, rollback instructions provided

## Quick Examples by Use Case

### Starting Fresh
```bash
# Copy methodology
cp -r livespec/prompts .livespec

# Create structure
mkdir -p specs/{workspace,1-requirements/{strategic,functional},2-strategy,3-behaviors,3-contracts}

# Use first prompt
# "Use .livespec/0-define/0a-setup-workspace.md"
```

### Documenting Existing Code
```bash
# Use extract prompt on existing codebase
# "Use .livespec/4-evolve/4b-extract-specs.md to document this codebase"
```

### Checking for Drift
```bash
# Run drift detection
# "Use .livespec/4-evolve/4a-detect-drift.md"
```

### Designing New Feature
```bash
# Use design prompts
# "Use .livespec/1-design/1b-define-behaviors.md for [feature]"
```

## Integration with Context7

When using Context7:
```bash
# Fetch LiveSpec methodology remotely
"Use @context7/chrs-myrs/livespec methodology"
```

Context7 will provide:
- This AGENTS.md file (cache it!)
- Full prompt files as needed
- MSL guide
- Examples

## Development Patterns

**From specs/workspace/patterns.spec.md:**

- All specs use MSL format (.spec.md extension: title, frontmatter, Requirements section)
- British English for user docs (synchronisation, behaviour)
- Phase-letter naming for prompts (0a-, 1b-, 2c-)
- One spec per behavior
- Workspace/product separation in folder structure

## Development Workflows

**From specs/workspace/workflows.spec.md:**

- New prompts require behavior specs first
- Spec changes follow EVOLVE phase workflow
- Changes validated through real usage before merge
- Periodic MSL audits maintain minimalism
- Documentation updates accompany prompt/spec changes

## Reference Library (Deep Detail Navigation)

AGENTS.md provides 80% coverage. For deep detail, fetch these references using `.livespec/` paths:

### Conventions (How to Structure)

**Context Compression** - `.livespec/standard/conventions/context-compression.spec.md`
- **Fetch when**: Deciding inline vs extract, optimizing AGENTS.md size, migrating compression levels
- **Provides**: Full compression framework, decision criteria, extraction patterns
- **Cross-ref**: See "Context Compression" section for summary

**Folder Structure** - `.livespec/standard/conventions/folder-structure.spec.md`
- **Fetch when**: Creating spec folders, unclear where file belongs, multi-domain organization
- **Provides**: Folder organization tests, workspace vs strategy vs behaviors classification
- **Cross-ref**: See "Folder Organization Decision Tests" section

**Dependencies** - `.livespec/standard/conventions/dependencies.spec.md`
- **Fetch when**: Managing spec relationships, frontmatter links, dependency graphs
- **Provides**: Frontmatter conventions, bidirectional linking, dependency types
- **Cross-ref**: See "Specification Dependencies" section

**Naming Conventions** - `.livespec/standard/conventions/naming.spec.md`
- **Fetch when**: Creating files, unsure of naming pattern, standardizing extensions
- **Provides**: File naming patterns, extension conventions, phase-letter naming

### Metaspecs (Templates for Spec Types)

**Prompt** - `.livespec/standard/metaspecs/prompt.spec.md`
- **Fetch when**: Writing new prompts, creating Phase 0-4 workflows

**Behavior** - `.livespec/standard/metaspecs/behavior.spec.md`
- **Fetch when**: Writing behavior specs, defining observable outcomes

**Contract** - `.livespec/standard/metaspecs/contract.spec.md`
- **Fetch when**: Writing API/data contracts, defining interfaces

**Workspace** - `.livespec/standard/metaspecs/workspace.spec.md`
- **Fetch when**: Creating workspace specs, defining project governance

**Others**: `base.spec.md`, `constraints.spec.md`, `outcomes.spec.md`, `purpose.spec.md`, `strategy.spec.md`

### Guides (How to Apply)

**MSL Minimalism** - `.livespec/guides/msl-minimalism.md`
- **Fetch when**: Spec too verbose, applying minimalism framework, auditing requirements
- **Provides**: Complete MSL decision framework, requirement hierarchy
- **Cross-ref**: See "MSL Minimalism" principle

**TDD** - `.livespec/guides/tdd.md`
- **Fetch when**: Implementing TDD workflow, writing tests before code
- **Provides**: Complete TDD process, spec-to-test mapping
- **Cross-ref**: See Phase 2 (BUILD)

**Context Positioning** - `.livespec/guides/context-positioning.md`
- **Fetch when**: Optimizing AGENTS.md structure, START/MIDDLE/END pattern
- **Provides**: Research-backed positioning framework

**AI Commits** - `.livespec/guides/ai-commits.md`
- **Fetch when**: Creating git commits, following commit standards
- **Provides**: Commit message format, Git safety protocol

### Navigation Pattern

When AGENTS.md mentions a topic, look for "See Reference Library: [file]" to find detailed spec.

## Final Notes

LiveSpec is just folders and markdown. The methodology guides AI agents to:

1. **Create proper specifications** (Phase 0-1)
2. **Implement from specs** (Phase 2)
3. **Validate correctness** (Phase 3)
4. **Keep specs synchronized** (Phase 4)

Remember: **Start simple, add complexity only when needed. Trust the phases.**

---
*Agent configuration for [LiveSpec v3.1.0](https://github.com/chrs-myrs/livespec) - Generated 2025-10-27*
